---
layout: post
title:  "윈도우(창) 만들기"
categories: win32
tags: [win32]
---
> 이 글은 [directx11 튜토리얼 코드](https://github.com/microsoft/DirectX-SDK-Samples/blob/main/C%2B%2B/Direct3D11/Tutorials/Tutorial01/Tutorial01.cpp)를 기준으로 합니다.

프로그램이 실행되고 `wWinMain()`가 호출되면 가장 먼저 `InitWindow`를 통해서 [창 클래스(윈도우 클래스)](https://learn.microsoft.com/ko-kr/windows/win32/learnwin32/creating-a-window)를 등록한다. 윈도우 클래스는 만들고자 하는 윈도우(창)의 속성을 저장하고 있는 데이터 구조로, 운영 체제에서 관리된다.

```cpp
int WINAPI wWinMain( _In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow )
{
    UNREFERENCED_PARAMETER( hPrevInstance );
    UNREFERENCED_PARAMETER( lpCmdLine );

    if( FAILED( InitWindow( hInstance, nCmdShow ) ) )
        return 0;
    ...
}

...

HRESULT InitWindow( HINSTANCE hInstance, int nCmdShow )
{
    // Register class
    WNDCLASSEX wcex;
    wcex.cbSize = sizeof( WNDCLASSEX );
    wcex.style = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc = WndProc;
    wcex.cbClsExtra = 0;
    wcex.cbWndExtra = 0;
    wcex.hInstance = hInstance;
    wcex.hIcon = LoadIcon( hInstance, ( LPCTSTR )IDI_TUTORIAL1 );
    wcex.hCursor = LoadCursor( nullptr, IDC_ARROW );
    wcex.hbrBackground = ( HBRUSH )( COLOR_WINDOW + 1 );
    wcex.lpszMenuName = nullptr;
    wcex.lpszClassName = L"TutorialWindowClass";
    wcex.hIconSm = LoadIcon( wcex.hInstance, ( LPCTSTR )IDI_TUTORIAL1 );
    if( !RegisterClassEx( &wcex ) )
        return E_FAIL;

    // Create window
    g_hInst = hInstance;
    RECT rc = { 0, 0, 800, 600 };
    AdjustWindowRect( &rc, WS_OVERLAPPEDWINDOW, FALSE );
    g_hWnd = CreateWindow( L"TutorialWindowClass", L"Direct3D 11 Tutorial 1: Direct3D 11 Basics",
                           WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX,
                           CW_USEDEFAULT, CW_USEDEFAULT, rc.right - rc.left, rc.bottom - rc.top, nullptr, nullptr, hInstance,
                           nullptr );
    if( !g_hWnd )
        return E_FAIL;

    ShowWindow( g_hWnd, nCmdShow );

    return S_OK;
}
```

# `WNDCLASSEX`
윈도우 클래스는 `WNDCLASS`라는 구조체에 속성을 담아서 등록할 수 있다.
```cpp
typedef struct tagWNDCLASSEXW {
  UINT      cbSize;
  UINT      style;
  WNDPROC   lpfnWndProc;
  int       cbClsExtra;
  int       cbWndExtra;
  HINSTANCE hInstance;
  HICON     hIcon;
  HCURSOR   hCursor;
  HBRUSH    hbrBackground;
  LPCWSTR   lpszMenuName;
  LPCWSTR   lpszClassName;
  HICON     hIconSm;
} WNDCLASSEXW, *PWNDCLASSEXW, *NPWNDCLASSEXW, *LPWNDCLASSEXW;
```

참고로 구조체 이름의 접미사인 `W`와 `A`는 내부에서 문자열을 유니코드(w) 방식으로 처리할 것인지, ANSI(a) 방식으로 처리할 것인지의 차이이다. 현재는 `A`를 를 써도 `W`로 변환되어서 처리된다고 한다. 구조체를 구성하는 멤버들은 [이 문서](https://learn.microsoft.com/ko-kr/windows/win32/api/winuser/ns-winuser-wndclassexw)를 참고하자. 이 중 중요한것만 고르자면
`lpfnWndProc`, `hInstance`, `lpszClassName`이 있다.

## `lpfnWndProc`
윈도우즈에서는 윈도우 클래스에 [창 프로시저](https://learn.microsoft.com/ko-kr/windows/win32/winmsg/window-procedures)라는 함수의 주소를 등록하여 윈도우 클래스에 전달되는 모든 "메세지"(마우스 움직임, 타이머 등)를 해당 함수로 전달한다. 

## `hInstance`
윈도우 클래스를 생성한 프로그램 인스턴스를 등록한다. 프로그램이 종료되면 윈도우 클래스도 같이 사라진다.

## `lpszClassName`
윈도우 클래스의 이름을 지정한다. `lpsz`는 long, pointer, string, zero-terminated를 의미하고, [이름은 프로세스 내부에서만 중복되지 않으면 된다](https://learn.microsoft.com/en-us/windows/win32/winmsg/about-window-classes#class-name). 왜 클래스에 문자열 이름을 부여하나 했는데, Windows API에서 윈도우 클래스를 이용할 때, 오브젝트가 아니라 문자열 형식으로 접근하는 것 같다. 아마 다른 프로그램과의 연동을 위해서인 것 같다. 이 문자열은 이후 윈도우 클래스가 `RegisterClassEx`를 통해 등록이 될 때, 프로세스의 [Atom 테이블](https://learn.microsoft.com/ko-kr/windows/win32/dataxchg/about-atom-tables)내에서 16비트 정수값을 부여받는다.

---

출처:
<https://github.com/microsoft/DirectX-SDK-Samples/blob/main/C%2B%2B/Direct3D11/Tutorials/Tutorial01/Tutorial01.cpp>
<https://stackoverflow.com/questions/902967/what-is-a-windows-handle>
<http://www.directxtutorial.com/Lesson.aspx?lessonid=11-1-2>
<https://chanos.tistory.com/entry/Windows-API-Win32-API의-기본구조-WinMain-2>